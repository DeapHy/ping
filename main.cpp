#include "main.h"
#include "init.h"
#include "log.h"
#include "request.h"
#include "response.h"

/*                  ---Определение функции main---
*   Функция main является точкой входа в программу и осуществляет вызов функций, необходимых для работы утилиты.
*   В качестве начальных входных параметров функция main получает набор аргументов argc и argv,
*       где argc - количество переданных параметров; 
*           argv - массив входных параметров, введенных пользователяем.
*   Пользователь может вводить любое кол-во параметров запуска, но корректно обрабатываться будет только последовательность 2 параметра.
*   Программа запускается в формате: ping <Ip-address OR HostName>
*                   ---Пример---
*               ping yandex.ru
*               где argc = 2;
*               Содержимое argv:
*               argv[0] = ping
*               argv[1] = yandex.ru
*               ---END ПРИМЕР---
*
* Коды ошибок:
* 0 - Успешное завершение
* 10 - Категория ошибок, связанная с ошибкой файла лога
* 20 - Категория ошибок, связанная с ошибками обработки входных аргументов
* 30 - Категория ошибок, связанная с ошибками инициализации (по большей части сокет)
* 40 - Категория ошибок, связанная с ошибками DNS (Если не проинициализировать структуры, мы не сможем проверить, доменное имя передал пользователь или IP)
* 50 - Категория ошибок, связанная с ошибками сборки ICMP пакета
* 60 - Категория ошибок, связанная с ошибками отправки пакета
* 70 - Категория ошибок, связанная с ошибками получения пакета
* 
*/
int main(int argc, char* argv[])
{
    // ============================================ СОЗДАНИЕ ВСЕХ НЕОБХОДИМЫХ ПЕРЕМЕННЫХ, СТРКУТУР И ПРОЧЕГО ВСЕГО ============================================
    setlocale(LC_ALL, "Russian");                   // Установка русского языка для правильности вывода русских символов
    ofstream log;                                   // Объект класса для работы с файлом лога
    int returnCode = 0;                             // Код возврата, пока как переменная
    SOCKET listn = { 0 };                           // Объект сокета, с которым работает программа в процессе отправки и принятия аргументов
    char* Icmp = new char[1];                       // Переменная, в которой будет храниться
    IcmpHeader pac;                                 // Структура, содержащая ICMP заголовок
    IcmpHeader* Packet;                             // Указатель на структуру, содержащую ICMP заголовок
    int incr = 0;                                   // Переменная, используемая в цикле
    char bf[BUFFER_SIZE] = { 0 };                   // Буфер для ответа
    LOGINFO logger = {"", 0, 0};                    // Структура для хранения текста ошибки, кода ошибки и времени когда произошла ошибка

    // Удаленный адрес
    SOCKADDR_IN list_adr = { 0 };                   // Структура SOCKADDR_IN описывает сокет для работы с протоколами IP. Данная структура используется для удаленного устройства

    // Локальный адрес
    SOCKADDR_IN bnd = { 0 };                        // Данная структура используется для локального устройства

    // Получаемый пакет
    SOCKADDR_IN out_ = { 0 };                       // Данная структура используется для обработки полученного ответа
    WSADATA wsd = { 0 };                            // Структура содержит информацию о реализации сокета
    // ========================================================================================================================================================

    // Создание лога и обработка его ошибок
    switch (createLog(log)) {
    case 0:
        // Удачное выполнение функции
        break;
    case 1:
        // Ошибка при выполнении
        cout << "Error code = 10" << endl; // ДЕБАГ

        // Запись ошибки в лог через конструкцию switch case (как я сделал выше)
        return 10;
        break;
    }

    // Проверка входных аргументов (если есть ошибки - вывод куда-нибудь уже)
    switch (checkArgs(argc, logger)) {
    case 0:
        // Удачное выполнение функции
        break;
    case 1:
        // Ошибка при выполнении
        cout << "Error code = 20" << endl;
        // Запись ошибки в лог через конструкцию switch case (как я сделал выше)
        return 20;
        break;
    }

    char* Ip = argv[1];                             // Пингуемый адрес.

    // Определение структур и сокета для работы
    switch(init(Ip, list_adr, bnd, out_, wsd, listn, logger)) {
    case 0:
        // Успешное выполнение
        break;
    case 1:
        // Ошибка при выполнении
        cout << "Error code = 30" << endl; // ДЕБАГ
        // Запись ошибки в лог через конструкцию switch case (как я сделал выше)
        return 30;
        break;
    }

    // Проверка на ввод DNS или обычного айпи
    switch (getIPByName(list_adr, bnd, Ip, listn, logger)) {
    case 0:
        // Успешное выполнение
        break;
    case 1:
        // Ошибка при выполнении
        cout << "Error code = 40" << endl; // ДЕБАГ
        // Запись ошибки в лог через конструкцию switch case (как я сделал выше)
        return 40;
        break;
    }

    // Сборка пакета + вычисление контрольной суммы
    switch (assembling(pac, Packet, Icmp)) {
    case 0:
        // Успешное выполнение
        break;
    case 1:
        // Ошибка при выполнении
        cout << "Error code = 50" << endl; // ДЕБАГ
        // Запись ошибки в лог через конструкцию switch case (как я сделал выше)
        return 50;
        break;
    }

    while (incr < 4) {

        // Отправка пакета
        switch(request(Packet, listn, list_adr)) {
        case 0:
            // Успешное выполнение
            break;
        case 1:
            // Ошибка при выполнении
            cout << "Error code = 60" << endl; // ДЕБАГ
            // Запись ошибки в лог через конструкцию switch case (как я сделал выше)
            return 60;
            break;
        }

        // Получение ответа
        switch(response(listn, bf, out_, incr)) {
        case 0:
            // Успешное выполнение
            break;
        case 1:
            // Ошибка при выполнении
            cout << "Error code = 70" << endl; // ДЕБАГ
            // Запись ошибки в лог через конструкцию switch case (как я сделал выше)
            return 70;
            break;
        }
        incr++;
    }
    
    finish(Icmp, listn);
    return returnCode;
}